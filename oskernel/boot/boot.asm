;yanxiang在此说明：此个文件boot.asm  用来模拟MBR的部分功能的
;MBR（主引导程序） 位于硬盘的 0磁道，0柱面，1扇区中，其中主要记录了启动引导程序和磁盘的分区表
;MBR 是被BIOS加载到此处，（起始地址在0X7C00，结束地址0X7DFF，总共512B） ，其446B安装了启动引导程序，其后面64B是描述分区表，最后的2B是结束标记（55 AA）
[ORG 0X7C00]                        ;ORG 是一个伪指令，用于指定程序中的代码或数据在内存中的起始地址；它不会生成机器代码； 程序的起始地址为0X7C00

[SECTION .data]                     ;伪指令；声明了数据段，数据段通常是用来存储程序中的全局变量，常量和静态数据

BOOT_MAIN_ADDR equ 0x500            ;BOOT_MAIN_ADDR是一个常量；”equ“是一个伪指令，用于定义常量；
                                    ;在你的引导程序中，BOOT_MAIN_ADDR 被用来指定引导程序的主代码（或数据）将被加载到内存地址 0x500 处。
                                    ;如果想要把boot的控制权交给setup，则直接jimp 0x500跳出去，进入到setup的起点

[SECTION .text]                     ;声明代码段，用来存放可执行代码的
[BITS 16]                           ;声明代码是16位模式的
global _start                       ;声明“_start”是全局的，（以便于后期在C语言的环境中直接调用汇编的程序）

_start:                             ;程序的入口位置
    mov ax, 3                       ;把3写入到寄存器ax中；作用是把屏幕模式设置成为80X25文本模式  --为什么mov ax，3是这个模式是由BIOS决定的

    int 0x10                        ;int 0x10是BIOS中断，功能号为”0x10“--这个也是BIOS中断决定的

    ;将bootsect读入到0x7e00
    ;读盘
    mov ch, 0                       ;将寄存器ch设置为0，表示0柱面
    mov dh, 0                       ;将寄存器dh设置为0,表示0磁头
    mov cl, 2                       ;将寄存器cl设置为2，表示读取第2扇区
    mov bx, BOOT_MAIN_ADDR          ;把0x500表示数据，读入到此地址

    mov ah, 0X02                    ;将ah寄存器设置为0x02,表示执行磁盘读取操作
    mov al, 1                       ;设置al寄存器为1,表示要连续读取的扇区数为1
    mov dl, 0                       ;设置dl寄存器为0,表示使用第一个软盘驱动器（通常是A盘）

    int 0x13                        ;触发BIOS中断，功能号0x13是磁盘服务中断，用于执行磁盘操作

    mov si, jmp_to_setup            ;把jmp_to_setup（如以下标签所示）的字符串写入到si寄存器当中  ----SI寄存器
    call print                      ;调用print子程序，打印字符串
                                    ;如果要打印的话，一般都是这两个配合使用的，打印字符串，才能实现将字符串打印到屏幕上

    xchg bx,bx                      ;bochs调试断点

    jmp BOOT_MAIN_ADDR              ;无条件跳转到“BOOT_MAIN_ADDR”，即跳转到0x500

read_floppy_error:                  ;是一个错误处理标签，表示如果磁盘读取失败，即将跳转到这里来
    mov si,read_floppy_error_msg    ;将si寄存器设置为错误信息“read_floppy_error_msg”的地址    ----SI寄存器
    call print                      ;调用print子程序，显示错误信息
    jmp $                           ;进入无限循环，即停留在此处，防止程序继续运行

print:                              ;打印print标签
    mov ah, 0x0e                    ;0x0e表示通过BIOS TTY模式显示字符（输出字符到屏幕上）；在这个模式上AL寄存器中的字符会被显示在屏幕上；
    mov bh, 0                       ;BH寄存器指定显示页号，通常在大多数情况下使用显示页0 （默认页）
    mov bl, 0x01                    ;BL寄存器设置显示的字符属性，0x01通常表示显示字符为高亮白色

.loop:                              ;一个循环的标签（带.的标签是局部标签【比如.loop】）
    mov al, [si]                    ;这条指令从si寄存器指向的内存地址读取一个字节，并将其存储在AL寄存器中，SI寄存器中保存的是字符串的起始地址，随着每次读取，si会逐渐指向下一个字符
    cmp al, 0                       ;将AL寄存器中的值与“0”进行比较，“0”是字符串的结束标志
    jz .done                        ;”jz“表示“如果等于则跳转到.done
    int 0x10                        ;调用BIOS的视频中断“int 0x10”，将al寄存器中的字符输出到屏幕上
    inc si                          ;inc si：表示si寄存器自增1,指向下一个字符
    jmp .loop                       ;无条件跳回loop，继续循环读取显示下一个字符

.done:                              ;标签
    ret                             ;返回到调用print的地方

jmp_to_setup:                       ;跳转到setup的一个标签
    db "yanxiang_os jump to setup...", 10, 13, 0     ;"db"一个伪指令，用来定义字节（8位数据）并且将其存储在内存中；可以使用“db”来定义字符串，数值或者任何字节级的数据
                                                     ;"10"表示光标移动到下一行； "13"表示光标回到行首   通常“10,13”表示换行操作；“0”表示字符串结束符
read_floppy_error_msg:                               ;......
    db "read floppy error!", 10, 13, 0               ;......

jmp_to_setup:                                        ;......
    db "jump to setup...", 10, 13, 0                 ;......

times 510 - ($ - $$) db 0                            ;“times” 重复执行的次数（从头到尾按顺序执行的）
                                                     ;前面的[ORG 0X7C00]表示当前代码的起始位置
                                                     ;“$”表示当前位置（以字节为单位）
                                                     ;“$$”表示当前代码的起始位置（以字节为单位）
                                                     ;510-（$-$$）表示510-当前代码已经生成的字节数 ：计算出还需要填充的字节数
                                                     ;db 0 ；表示用0x00字节填充这些空位

db 0x55, 0xaa                                        ;因为一个扇区就是512字节，前面已经占完了  所以：明确在最后两个字节填入引导扇区标志“0x55”和“0xAA”